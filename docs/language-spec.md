# IRIS: Синтаксис языка

## Описание

Синтаксис во многом похож на `C` но выполнен на русском языке с некоторыми поправками.

Так как на русской раскладке клавиатуры нет символов `{`, `}`, `[` и `]`, было принято решение заменить их ключевыми
словами. Так, например, `нч` и `кц` это `{` и `}` соответственно.

## Примеры и сравнение с `C`

### Переменные

Типов данных *необходимо для тестов* всего два: целое число и булевая переменная.

```iris
<тип-данных> <имя>
```

#### Примеры

```iris
целч ц; // по умолчанию - 0
ц = 69;

бул п;  // по умолчанию - ложь
п = правда;

// Можно инициализировать переменные сразу с значениями
целч иниц = 10;
бул л = ложь;
```

```c
int i;
i = 69;

bool t;
t = true;

int init = 10;
bool f = false;
```

### Операторы и `целч`

Всё логично, все те же что и в `C`.

```iris
<выражение> <оператор> <выражение>
```

#### Примеры

```iris
целч результат;

// ничего удивительного
результат = 1 + 2;
результат = 3 - 1;
результат = 2 * 4;
результат = 6 / 2;
результат = 30 % 3;
```

```c
int result;

result = 1 + 2;
result = 3 - 1;
result = 2 * 4;
resutl = 6 / 2;
result = 30 % 3;
```

### Операторы и `бул`

Тут есть проблемы: на русской раскладке помимо `[]` и `{}` нет также и `&`, чтобы обойти эту проблему, пойдём путём
питона и будем записывать булевые операции словами.

```iris
<выражение> <оператор> <выражение>
```

#### Примеры

```iris
бул результат;

// но оператор "префиксный `!`" оставим
result = правда и правда;
result = правда или ложь;
result = ложь или правда и правда;
resutl = !ложь;
result = !(ложь и ложь);
```

```c
bool result;

result = true && true;
result = true || false;
result = false || true && true;
resutl = !false;
result = !(false || false);
```

### Ветвление

В целом так же как и в `C`. Но из-за `нч` и `кц` выглядит немного жутко.

```iris
если (<выражение-бул>) нч
    // код
кц иначе если (<выражение-бул>) нч
    // код
кц иначе нч
    // код
кц
```

#### Примеры

```iris
целч возраст;
возраст = 20;

если (возраст > 18) нч
    // одно
кц иначе если (возраст == 18) нч
    // другое
кц иначе нч
    // третье
кц
```

```c
int age;
age = 20;

if (age > 18) {
    // одно
} else if (age == 18) {
    // другое
} else {
    //третье
}
```

### Циклы

Достаточно только цикла `while`.

```iris
пока (<выражение-бул>) нч
    // код
кц
```

#### Пример

```iris
целч ч; // по умолчанию - 0

пока (правда) нч
    ч = ч + 1;
    если (ч == 5) нч
        продолжить;
    кц иначе если (ч == 10) нч
        выйти;
    кц
кц
```

```c
int x = 0;

while (true) {
    x = x + 1;
    if (x == 5) {
        continue;
    } else if (x == 10) {
        break;
    }
}
```

### Функции

Тоже поэкспериментировал с декларацией функций. Возможно изменим.

```iris
процедура <имя-процедуры>(<тип-данных> <имя-параметра>, ...) нч
    // код
кц

функция:<тип-данных> <имя-функции>(<тип-данных> <имя-параметра>, ...) нч
    // код
    вернуть <выражение>;
кц
```

#### Пример

```iris
процедура действие() нч
    // Действия
кч

функция:целч увеличить(целч ч) нч
    вернуть ч + 1;
кц

функция:целч сложить(целч а, целч б) нч
    вернуть а + б;
кц
```

```c
void action() {
    // Действия
}

int increment(int x) {
    return x + 1;
}

int add(int x, int y) {
    return x + y;
}
```

### Вывод

Никаких строк, только суровые целч'и и бул'ы.

```iris
печать:<число/бул/идентификатор переменной>
печать:(<выражение>)
```

```iris
целч ч;
ч = 4;
печать:ч;   // 4

бул б;
б = правда;
печать:б;  // правда

печать:(ч + 3)
```

```c
int i;
i = 4;
printf("%d\n", i);

bool b;
b = true;
if (b) {
    prinf("правда");
} else {
    prinf("ложь");
}

printf("%d\n", i + 4);
```

### Структуры

Со структурами всё почти как в `C` только при создании экземпляра структуры убрали `struct`.

```iris
структура <Имя> нч
    <тип-данных> <имя-поля>
    ...
кц
```

#### Примеры

```iris
структ Точка2д нч
    целч абцисса;
    целч ордината:
кц

// Оператор `.` для доступа к полям
Точка2д а;
а.абцисса = 6;
а.ордината = 7;
```

```c
struct Point2d {
    int x;
    int y;
}

struct Point2d a;
a.x = 6;
a.y = 7;
```

### Указатели

С указателями берём синтаксис более похожий на плюсы (избегаем необходимости писать стандартную библиотеку)

```iris
<тип-данных>* <имя-указателя>
новый:<тип-данных>
```

#### Примеры

```iris
целч* укз;
укз = новый:целч;

Точка2д* укз_а;
укз_а = новый:Точка2д;
```

### Операторы и указатели

Опять проблемы с раскладками, для оператора возвращающего адрес переменной взяли оператор "префиксный `?`" (типа "где?")

```iris
*<указатель>    // разыменование
?<переменная>   // адрес переменной
```

#### Примеры

```iris
целч а = 10;
целч* ук_а = ?а;
целч результат = a + *ук_а;
```

```c
int a = 10;
int* a_pt = &a
int result = a + *a_pt;
```

### Массивы

Мне кажется лучше отказаться от массивов на стеке, чтобы не мучаться с VLA. Поэтому и все стековые массивы тоже минус.

Создание массивов же тоже делаем через `новый`, и в результате должно получиться поведение, похожее на `calloc()` из
`<stdlib.h>` в `C`.

```iris
новый:<тип-данных>:<число/идентификатор-переменной-целч>
новый:<тип-данных>:(<выражение-целч>)
```

#### Примеры

```iris
целч* массив;
массив = новый:целч:5;

целч размер;
размер = 10;
целч* другой_массив;
другой_массив = новый:целч:размер;          // массив на куче размера, потенциально неизвестного во время компиляции (VLA но на куче)
другой_массив = новый:целч:(размер + 4);    // тут может быть выражение (expression)
```

### Операторы и указатели (продолжение)

Указатели можно складывать с целч'ами, чтобы получить соседние адреса памяти.

```iris
<указатель> + <целч>
<целч> - <указатель>    // порядок не важен
```

#### Примеры

```iris
целч* массив = новый:целч:5;
целч* ук = массив+3;
целч результат = *ук;   // значение 2го элемента массива
```

```c
int* arr = (int*)malloc(sizeof(int)*5);
int* ptr = arr+3;
int result = *ptr;
```

### Обоснование чрезмерного использования ":"

Чтобы разделить функции языка от функций/процедур написанных пользователем.

### Общий список функций языка:

#### Ключевые слова

```iris
целч
бул
и
или
нч
кц
если
иначе
пока
процедура
функция
структура
```

#### Встроенные функции

```iris
печать:<целч>
печать:(<выражение-целч>)

новый:<тип>
новый:<тип>:<целч>
новый:<тип>:(<выражение-целч>)
```

#### Операторы

```iris
<целч> + <целч>
<целч> - <целч>
<целч> * <целч>
<целч> / <целч>
<целч> % <целч>

<бул> и <бул>
<бул> или <бул>
!<бул>

<структура>.<поле>

<процедура-функця>(<параметры>) // вызов (да, технически, это оператор)

?<целч-бул-структура>
*<указатель>

<указатель> + <целч>
<указатель> - <целч>
```

### Точка входа программы

Было принято решение отказаться от входной функции, так как большой сложности в целях этого языка не будет и можно
выполнять программы из глобального контекста.
