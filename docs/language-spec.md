# IRIS: Синтаксис языка

## Описание

Синтаксис во многом похож на `C` но выполнен на русском языке с некоторыми поправками.

Так как на русской раскладке клавиатуры нет символов `{`, `}`, `[` и `]`, было принято решение заменить их ключевыми
словами. Так, например, `нч` и `кц` это `{` и `}` соответственно.

## Примеры и сравнение с `C`

### Переменные

Типов данных *необходимо для тестов* всего два: целое число и булевая переменная.

```iris
<тип-данных> <имя>
```

#### Примеры

```iris
целч и // по умолчанию - 0
и = 69;

бул п  // по умолчанию - ложь
п = правда

бул л
л = ложь
```

```c
int i;
i = 69;

bool t;
t = true;

bool f;
f = false;
```

### Операторы

Всё логично, все те же что и в `C`.

```iris
<выражение> <оператор> <выражение>
```

#### Примеры

```iris
целч результат

// ничего удивительного
результат = 1 + 2
результат = 3 - 1
результат = 2 * 4
результат = 6 / 2
результат = 30 % 3
```

### Массивы (стековые)

С синтаксисом массивов поэкспериментировали из-за того что нет `[]`.

```iris
<тип-данных>:<размер> <имя>
```

#### Примеры

```iris
целч:5 цифры

целч размер
размер = 5

целч:размер числа
```

```c
int digits[5];

int size;
size = 5;

int nums[size];
```

### Ветвление

В целом так же как и в `C`. Но из-за `нч` и `кц` выглядит немного жутко.

```iris
если (<выражение-бул>) нч
    // код
кц иначе если (<выражение-бул>) нч
    // код
кц иначе нч
    // код
кц
```

#### Примеры

```iris
целч возраст
возраст = 20

если (возраст > 18) нч
    // одно
кц иначе если (возраст == 18) нч
    // другое
кц иначе нч
    // третье
кц
```

```c
int age;
age = 20;

if (age > 18) {
    // одно
} else if (age == 18) {
    // другое
} else {
    //третье
}
```

### Циклы

Достаточно только цикла `while`.

```iris
пока (<выражение-бул>) нч
    // код
кц
```

#### Пример

```iris
целч ч // по умолчанию - 0

пока (правда) нч
    ч = ч + 1
    если (ч == 5) нч
        продолжить
    кц иначе если (ч == 10) нч
        выйти
    кц
кц
```

```c
int x = 0;

while (true) {
    x = x + 1;
    if (x == 5) {
        continue;
    } else if (x == 10) {
        break;
    }
}
```

### Функции

Тоже поэкспериментировал с декларацией функций. Возможно изменим.

```iris
процедура <имя-процедуры>(<тип-данных> <имя-параметра>, ...) нч
    // код
кц

функция:<тип-данных> <имя-функции>(<тип-данных> <имя-параметра>, ...) нч
    // код
кц
```

#### Пример

```iris
процедура действие() нч
    // Действия
кч

функция:целч увеличить(целч ч) нч
    вернуть ч + 1
кц

функция:целч сложить(целч а, целч б) нч
    вернуть а + б
кц
```

```c
void action() {
    // Действия
}

int increment(int x) {
    return x + 1;
}

int add(int x, int y) {
    return x + y;
}
```

### Вывод

Никаких строк, только суровые целч'и.

```iris
печать:(<выражение-целч>)
```

```iris
целч ч
ч = 4
печать:(ч)  // 4

бул б;
б = правда;
печать:(б);  // правда
```

```c
int i;
i = 4;
printf("%d\n", i);

bool b;
b = true;
if (b) {
    prinf("правда");
} else {
    prinf("ложь");
}
```

### Структуры

Со структурами всё почти как в `C` только при создании экземпляра структуры убрали `struct`.

```iris
структ <Имя> нч
    <тип-данных> <имя-поля>
    ...
кц
```

#### Примеры

```iris
структ Точка2д нч
    целч абцисса
    целч ордината
кц

Точка2д а
а.абцисса = 6
а.ордината = 7
```

```c
struct Point2d {
    int x;
    int y;
}

struct Point2d a;
a.x = 6;
a.y = 7;
```

### Указатели и куча

С указателями берём синтаксис более похожий на плюсы (избегаем необходимости писать стандартную библиотеку)

```iris
<тип-данных>* <имя-указателя>
новый:<тип-данных>
новый:<тип-данных>:(<выражение-целч>)
```

#### Примеры

```iris
целч* укз
укз = новый:целч

Точка2д* укз_а
укз_а = новый:Точка2д

целч* массив
массив = новый:целч:5          // массив на куче размера, известного во время компиляции

целч размер
размер = 10
целч* другой_массив
массив = новый:целч:размер          // массив на куче размера, потенциально неизвестного во время компиляции 
массив = новый:целч:(размер + 4)    // тут может быть выражение (expression)
```

### Обоснование чрезмерного использования ":"

Чтобы разделить функции языка от функций/процедур написанных пользователем.

### Точка входа программы

Было принято решение отказаться от входной функции, так как большой сложности в целях этого языка не будет и можно
выполнять программы из глобального контекста.
