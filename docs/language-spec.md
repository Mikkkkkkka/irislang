# IRIS: Синтаксис языка

## Описание

Синтаксис во многом похож на `C` но выполнен на русском языке с некоторыми поправками.

Так как на русской раскладке клавиатуры нет символов `{` и `}`, было принято решение заменить их ключевыми
словами. Так, например, `нч` и `кц` это `{` и `}` соответственно.

Индексация массивов выполняется через `[` и `]` (как в `C`).

## Примеры и сравнение с `C`

### Переменные

Базовые типы - целое число и булевая переменная; также доступны структуры и массивы.

```iris
<тип-данных> <имя>
```

#### Примеры

```iris
целч ц; // по умолчанию - 0
ц = 69;

бул п;  // по умолчанию - ложь
п = правда;

// Можно инициализировать переменные сразу с значениями
целч иниц = 10;
бул л = ложь;
```

```c
int i;
i = 69;

bool t;
t = true;

int init = 10;
bool f = false;
```

### Операторы и `целч`

Всё логично, все те же что и в `C`.

```iris
<выражение> <оператор> <выражение>
```

#### Примеры

```iris
целч результат;

// ничего удивительного
результат = 1 + 2;
результат = 3 - 1;
результат = 2 * 4;
результат = 6 / 2;
результат = 30 % 3;
```

```c
int result;

result = 1 + 2;
result = 3 - 1;
result = 2 * 4;
result = 6 / 2;
result = 30 % 3;
```

### Операторы и `бул`

Тут есть проблемы: на русской раскладке помимо `[]` и `{}` нет также и `&`, чтобы обойти эту проблему, пойдём путём
питона и будем записывать булевые операции словами.

```iris
<выражение> <оператор> <выражение>
```

#### Примеры

```iris
бул результат;

// но оператор "префиксный `!`" оставим
результат = правда и правда;
результат = правда или ложь;
результат = ложь или правда и правда;
результат = !ложь;
result = !(ложь и ложь);
```

```c
bool result;

result = true && true;
result = true || false;
result = false || true && true;
result = !false;
result = !(false || false);
```

### Ветвление

В целом так же как и в `C`. Но из-за `нч` и `кц` выглядит немного жутко.

```iris
если (<выражение-бул>) нч
    // код
кц иначе если (<выражение-бул>) нч
    // код
кц иначе нч
    // код
кц
```

#### Примеры

```iris
целч возраст;
возраст = 20;

если (возраст > 18) нч
    // одно
кц иначе если (возраст == 18) нч
    // другое
кц иначе нч
    // третье
кц
```

```c
int age;
age = 20;

if (age > 18) {
    // одно
} else if (age == 18) {
    // другое
} else {
    //третье
}
```

### Циклы

Поддерживаются `while` и упрощенный `for`.

```iris
пока (<выражение-бул>) нч
    // код
кц
```

```iris
для (целч <переменная> от <выражение> до <выражение>) нч
    // код
кц
```

Диапазон: от стартового значения (включительно) до конечного (не включая), шаг всегда `+1`.

#### Пример

```iris
целч ч; // по умолчанию - 0

пока (правда) нч
    ч = ч + 1;
    если (ч == 5) нч
        продолжить;
    кц иначе если (ч == 10) нч
        выйти;
    кц
кц
```

```iris
целч сумма;

для (целч i от 0 до 10) нч
    сумма = сумма + i;
кц
```

```c
int x = 0;

while (true) {
    x = x + 1;
    if (x == 5) {
        continue;
    } else if (x == 10) {
        break;
    }
}
```

### Функции

Тоже поэкспериментировал с декларацией функций. Возможно изменим.

```iris
процедура <имя-процедуры>(<тип-данных> <имя-параметра>, ...) нч
    // код
кц

функция:<тип-данных> <имя-функции>(<тип-данных> <имя-параметра>, ...) нч
    // код
    вернуть <выражение>;
кц
```

#### Пример

```iris
процедура действие() нч
    // Действия
кч

функция:целч увеличить(целч ч) нч
    вернуть ч + 1;
кц

функция:целч сложить(целч а, целч б) нч
    вернуть а + б;
кц
```

```c
void action() {
    // Действия
}

int increment(int x) {
    return x + 1;
}

int add(int x, int y) {
    return x + y;
}
```

### Вывод

Никаких строк, только суровые целч'и и бул'ы. Булевые значения выводятся как `0` или `1`.

```iris
печать:<число/бул/идентификатор переменной>
печать:(<выражение>)
```

```iris
целч ч;
ч = 4;
печать:ч;   // 4

бул б;
б = правда;
печать:б;  // 1

печать:(ч + 3);
```

```c
int i;
i = 4;
printf("%d\n", i);

bool b;
b = true;
printf("%d\n", b ? 1 : 0);

printf("%d\n", i + 4);
```

### Структуры

Со структурами всё почти как в `C` только при создании экземпляра структуры убрали `struct`.

```iris
структура <Имя> нч
    <тип-данных> <имя-поля>
    ...
кц
```

#### Примеры

```iris
структура Точка2д нч
    целч абцисса;
    целч ордината;
кц

// Оператор `.` для доступа к полям
Точка2д а;
а.абцисса = 6;
а.ордината = 7;
```

```c
struct Point2d {
    int x;
    int y;
}

struct Point2d a;
a.x = 6;
a.y = 7;
```

### Массивы

Мне кажется лучше отказаться от массивов на стеке, чтобы не мучаться с VLA. Поэтому и все стековые массивы тоже минус.

Создание массивов же тоже делаем через `новый`, и в результате должно получиться поведение, похожее на `calloc()` из
`<stdlib.h>` в `C`.

```iris
новый:<тип-данных>:<число/идентификатор-переменной-целч>
новый:<тип-данных>:(<выражение-целч>)
```

#### Примеры

```iris
целч* массив;
массив = новый:целч:5;

целч размер;
размер = 10;
целч* другой_массив;
другой_массив = новый:целч:размер;          // массив на куче размера, потенциально неизвестного во время компиляции (VLA но на куче)
другой_массив = новый:целч:(размер + 4);    // тут может быть выражение (expression)
```

Доступ к элементам:

```iris
<массив>[<индекс>]
```

```iris
целч* массив = новый:целч:5;
массив[3] = 42;
целч значение = массив[3];
```

### Обоснование чрезмерного использования ":"

Чтобы разделить функции языка от функций/процедур написанных пользователем.

### Общий список функций языка:

#### Ключевые слова

```iris
целч
бул
и
или
нч
кц
если
иначе
пока
для
от
до
процедура
функция
структура
```

#### Встроенные функции

```iris
печать:<целч>
печать:(<выражение-целч>)

новый:<тип>
новый:<тип>:<целч>
новый:<тип>:(<выражение-целч>)
```

#### Операторы

```iris
<целч> + <целч>
<целч> - <целч>
<целч> * <целч>
<целч> / <целч>
<целч> % <целч>

<бул> и <бул>
<бул> или <бул>
!<бул>

<структура>.<поле>
<массив>[<индекс>]

<процедура-функция>(<параметры>)    // вызов (да, технически, это оператор)

```

### Точка входа программы

Было принято решение отказаться от входной функции, так как большой сложности в целях этого языка не будет и можно
выполнять программы из глобального контекста.
