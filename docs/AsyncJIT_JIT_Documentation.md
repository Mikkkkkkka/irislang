# AsyncJIT: Документация по JIT-компилятору (включая асинхронный пайплайн)

> Цель документа: описать **контракты, структуры данных, протоколы и поток исполнения** JIT в проекте AsyncJIT так, чтобы разработчик (и LLM-модель) могли реализовать **асинхронную часть компилятора** и корректно интегрировать её с VM/интерпретатором и GC.

---

## 1. Контекст и границы ответственности

Проект состоит из:
- **language_spec**: синтаксис/AST/генератор байткода.
- **vm (интерпретатор)**: выполнение байткода, стек, heap, вызовы, переходы.
- **jit_gc**: JIT-компиляция функций и сборщик мусора.

JIT-компилятор работает на уровне **функций**: единица компиляции = *одна функция байткода* (один блок инструкций).

### Ключевая идея асинхронного JIT
- VM **остается однопоточной** (исполнение только в потоке VM).
- Компиляция выполняется **в фоне** (корутины/пулы потоков).
- Пока компиляция не готова — VM **не блокируется**, а выполняет функцию интерпретатором (fallback).
- При ошибке компиляции функция помечается как **FAILED**, и VM **навсегда** использует интерпретатор для неё.

---

## 2. Требования к безопасности и корректности (контракт асинхронности)

Асинхронный JIT должен соблюдать следующие принципы:

1) **Генерация/линковка кода в фоне, исполнение — только в потоке VM**.  
2) Фоновый JIT читает только **immutable** структуры: байткод функций, пул констант, сигнатуры (арность/число локалов).  
3) Любой доступ к **heap/stack/roots** выполняется только внутри `execute(vm)` в потоке VM.  
4) Ошибка компиляции не ломает выполнение: **fallback обязателен**.

Практически это означает:
- фоновые задачи не должны трогать VM.stack/VM.heap и не должны читать/писать roots для GC;
- публикация результата компиляции должна быть потокобезопасной и не должна нарушать инварианты VM.

---

## 3. Модель состояния функции

Для каждой функции в модуле вводится состояние:

- `NOT_COMPILED` — ещё не ставили задачу на компиляцию.
- `COMPILING` — задача на компиляцию запущена в фоне.
- `READY` — скомпилированная версия доступна.
- `FAILED` — компиляция завершилась ошибкой, всегда fallback.

Переходы:
- `NOT_COMPILED -> COMPILING` (при первом CALL или при триггере "горячести").
- `COMPILING -> READY` (после успешной компиляции + публикации результата).
- `COMPILING -> FAILED` (если задача упала/вернула ошибку).
- `READY` и `FAILED` терминальны (в MVP можно не делать деоптимизацию и рекомпиляции).

---

## 4. Рекомендуемые структуры данных (для дедупликации и публикации результата)

Рекомендуемые структуры (как минимум для MVP):

- `jitJobs: ConcurrentHashMap<Int, Deferred<CompiledFunction>>`
  - ключ: `funcIndex`
  - значение: активная/уже созданная задача компиляции (дедупликация "compile-once").

- `jitCompiled: AtomicReferenceArray<CompiledFunction?>`
  - индексируемый массив результатов (опубликованных, видимых VM).

- `jitFailed: BooleanArray` **или** `BitSet` **или** `AtomicIntegerArray` со стейтами
  - быстрый флаг “не пытаться больше компилировать”.

> Вариант: вместо прямой публикации из фонового потока можно публиковать через очередь событий и применять её в VM потоке (см. §6.3).

---

## 5. Основные интерфейсы и контракты модулей

### 5.1. Контракт VM -> JIT (immutable input)
VM предоставляет JIT-у доступ **только** к неизменяемым данным (снимки/ссылки на read-only структуры):

```kotlin
interface JitCompiler {
  /** Компилирует funcIndex в фоне. Должно быть side-effect free относительно VM heap/stack. */
  fun compile(funcIndex: Int): CompiledFunction
}
```

Для компиляции JIT должен получить:
- байткод конкретной функции,
- пул констант,
- метаданные функции (число параметров, локалов, стек-лимиты, и т.п.).

Это можно оформить так:

```kotlin
interface BytecodeProvider {
  fun getFunctionBytecode(funcIndex: Int): ByteArray // или IntArray
  fun getConstPool(): LongArray // или List<Long>
  fun getFunctionMeta(funcIndex: Int): FunctionMeta  // arity, localsCount, etc.
}
```

### 5.2. Контракт JIT -> VM (установка результата)
JIT возвращает объект исполняемой функции (или указатель/хэндл), который VM сможет вызвать:

```kotlin
interface CompiledFunction {
  /** Исполняется ТОЛЬКО в потоке VM. Доступ к heap/stack допустим. */
  fun execute(vm: VirtualMachine)
}
```

Также полезно иметь установщик:

```kotlin
interface JitInstall {
  fun installCompiledFunction(funcIndex: Int, fn: CompiledFunction)
  fun markFailed(funcIndex: Int, cause: Throwable? = null)
}
```

---

## 6. Интеграция в CALL: поведение VM (асинхронный режим)

### 6.1. Правила выбора пути (READY/COMPILING/…)

На `CALL funcIndex` VM делает:

1) Если `jitCompiled[funcIndex] != null` → выполнить compiled.
2) Иначе если функция **не FAILED**:
   - если задачи нет — создать фоновой job компиляции;
   - выполнить fallback интерпретатором (не ждать компиляции).
3) Если FAILED → всегда интерпретатор.

### 6.2. Псевдокод CALL (рекомендуемый MVP)

```kotlin
fun call(funcIndex: Int) {
  val compiled = jitCompiled.get(funcIndex)
  if (compiled != null) {
    return compiled.execute(vm)
  }

  if (!jitFailed[funcIndex]) {
    jitJobs.computeIfAbsent(funcIndex) {
      scope.async(Dispatchers.Default) { jit.compile(funcIndex) }
        .also { job ->
          job.invokeOnCompletion { err ->
            if (err == null) jitCompiled.set(funcIndex, job.getCompleted())
            else jitFailed[funcIndex] = true
          }
        }
    }
  }

  // fallback while compiling (or if failed)
  interpretCall(funcIndex)
}
```

### 6.3. Публикация результата: два безопасных варианта

**Вариант A (прямо из фонового потока):**
- допустим, если `jitCompiled` — AtomicReferenceArray, и compiled-объект immutable.
- важно: compiled-объект не должен содержать ссылок на изменяемые структуры VM, кроме как через аргумент `execute(vm)`.

**Вариант B (публикация через очередь событий VM):**
- фон кладёт `CompiledFunction` в `ConcurrentLinkedQueue<InstallEvent>`;
- VM периодически (в своём цикле) вычитывает очередь и делает `jitCompiled.set(i, fn)`.
- этот вариант проще для reasoning о потоках и упрощает отладку.

---

## 7. Протокол с GC: stop-the-world и ограничения фона

GC работает в модели **stop-the-world** (исполнение VM приостанавливается для маркировки/свипа).

Контракт с асинхронным JIT:
- фоновые задачи **не трогают heap/roots** и не должны зависеть от текущего состояния объектов;
- compiled-код выполняется в VM потоке, и именно VM обеспечивает корректные точки, где можно запускать GC;
- если JIT требует метаданных объектов — эти метаданные должны быть либо immutable, либо получаться в VM потоке.

Рекомендация: JIT генерирует код так, чтобы аллокации шли через VM сервис (например, `vm.allocArray(size)`), который сам может триггерить GC.

---

## 8. Формат и ABI compiled-функций

Есть два практичных варианта для MVP.

### Вариант 1 (самый простой): CompiledFunction = Kotlin-объект (execute(vm))
- `CompiledFunction.execute(vm)` исполняет логику быстрее, чем интерпретатор, за счёт:
  - отсутствия fetch-decode-execute цикла,
  - специализации под конкретную функцию,
  - прямого кода (ветвления и операции уже в JVM байткоде метода).
- Можно генерировать `execute`:
  - вручную (как "супер-интерпретатор" под одну функцию),
  - или через ASM (генерация JVM байткода).

Плюсы: без JNI/Unsafe, проще запуск и отладка.  
Минусы: формально это "JIT поверх JVM", но всё равно JIT на лету (и работает).

### Вариант 2: Нативный код (x86-64) + вызов через JNI/JNA/FFI
- JIT генерирует байты машинного кода, размещает в исполняемой памяти, получает адрес.
- VM хранит таблицу `funcIndex -> nativePtr` и вызывает через bridging.
- Нужна реализация patching/jumps/calls и платформа-зависимые детали памяти (mmap/mprotect).

Плюсы: "настоящий" native JIT.  
Минусы: сложность вызова из JVM и безопасность.

> Для асинхронного пайплайна (тема этого документа) оба варианта одинаковы по потоковой модели: компилировать можно в фоне, выполнять — в VM потоке.

---

## 9. Трансляция байткода: минимальный набор, который должен понимать JIT

В MVP JIT должен корректно обработать хотя бы:
- `PUSH_CONST`, `ADD`, `SUB`, `MUL`, `DIV`
- сравнения (`CMP_EQ`, `CMP_LT` и т.п.)
- переходы `JMP`, `JMP_IF`
- локальные `LOAD idx`, `STORE idx`
- работу с массивами `ALLOC_ARR`, `LOAD_ARR`, `STORE_ARR` (через вызовы VM API)
- `CALL`, `RET` (можно начать с fallback на интерпретатор для CALL, но это сильно снижает профит; лучше поддержать прямые compiled-call после появления адресов).

### Прыжки и patching
Для `JMP` и `JMP_IF` при генерации нативного кода нужно соответствие:
- `bytecodeIndex -> machineOffset`

Обычно делается:
- **2 прохода**: сначала оценка размеров и расчёт оффсетов, затем эмит байтов.
- либо **patch later**: при эмите оставлять место под оффсет и позже патчить.

Эти таблицы нужны также для линковки `CALL` и для корректировки относительных переходов.

---

## 10. Обработка ошибок и политика fallback

Ошибки компиляции не должны:
- падать всю VM,
- ломать выполнение программ,
- портить состояние стека/кучи.

Политика:
- любая ошибка в compile-job → `FAILED` (функцию больше не компилировать),
- VM всегда имеет возможность выполнить исходный байткод интерпретатором.

Рекомендуется логировать:
- переходы состояний (NOT_COMPILED/COMPILING/READY/FAILED),
- причины ошибок компиляции,
- время компиляции,
- количество вызовов функции (если добавляете профилирование).

---

## 11. Рекомендованный план реализации асинхронной части (пошагово)

1) **Добавить таблицы в VM**: `jitJobs`, `jitCompiled`, `jitFailed` (или unified state array).
2) **Интегрировать CALL-путь** по псевдокоду из §6.
3) Реализовать `JitCompiler.compile(funcIndex)` как заглушку, возвращающую `CompiledFunction`, который:
   - либо вызывает интерпретатор той же функции (для теста пайплайна),
   - либо возвращает константу (ещё проще для smoke test).
4) Добавить публикацию результата:
   - сначала вариант B через очередь событий (проще отлаживать),
   - затем можно перейти на AtomicReferenceArray, если нужно.
5) Добавить тесты конкурентности:
   - много потоков/корутин создают вызовы одной функции — компиляция должна быть **ровно одна**,
   - после READY VM должна переходить на compiled.
6) Постепенно наращивать покрытие опкодов в реальном кодогенераторе.

---

## 12. Набор минимальных тестов (как acceptance)

### 12.1. Дедупликация компиляции
- Запустить программу, где одна функция вызывается 1000 раз.
- Проверить, что `compile(func)` вызван ровно 1 раз.

### 12.2. Fallback во время компиляции
- Искусственно замедлить `compile()` (sleep 200ms).
- VM должна продолжить корректно выполнять программу, интерпретируя функцию до READY.

### 12.3. FAILED навсегда
- `compile()` выбрасывает исключение.
- VM не должна пытаться компилировать снова и должна интерпретировать всегда.

### 12.4. Корректность состояния стека
- Вызов функции с аргументами + возвращаемое значение.
- Сравнить результаты интерпретатора и compiled.

---

## 13. Приложение: единый enum state вместо трёх структур (опционально)

Вместо `jitFailed + jitCompiled + jitJobs` можно завести:

```kotlin
enum class JitState { NOT_COMPILED, COMPILING, READY, FAILED }
val states = AtomicIntegerArray(funcCount) // ordinal
val compiled = AtomicReferenceArray<CompiledFunction?>(funcCount)
val jobs = ConcurrentHashMap<Int, Deferred<CompiledFunction>>()
```

Это упрощает reasoning о гонках (в одном месте видно state).

---

## 14. Источник требований (для команды)

Этот документ соответствует разделам “НОВОЕ: Архитектура асинхронного JIT” и “Приложение A. Асинхронный JIT — контракты и примеры” в исходном плане проекта.
